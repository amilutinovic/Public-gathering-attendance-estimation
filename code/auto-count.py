#!/usr/bin/env python3
"""
Count dots inside R-selected pilot cells and write results back to CSV.
Optionally:
  - flip the bitmap vertically (while mapping coords correctly),
  - save per-cell "clean count" previews,
  - save one whole-image "clean count" preview with all pilot cells + dots.

Inputs expected (generated by your R pipeline):
  --frame_csv: ./grid_output/strata_map_auto.csv
      columns: cell_id, img_path, x0, x1, y0, y1, (optionally include/stratum)
  --pilot_csv: ./outputs/sampling_outputs/pilot_to_count.csv
      columns: img_path, stratum, cell_id, y (to be filled)

Usage example:
  python count_cells_and_fill_pilot.py \
    --frame_csv ./grid_output/strata_map_auto.csv \
    --pilot_csv ./outputs/sampling_outputs/pilot_to_count.csv \
    --out_csv   ./outputs/sampling_outputs/pilot_to_count_filled.csv \
    --flip-bitmap \
    --preview-dir ./outputs/sampling_outputs/previews_cells \
    --image-preview-dir ./outputs/sampling_outputs/previews_images
"""

import sys
import argparse
from pathlib import Path
import numpy as np
import pandas as pd

from skimage import io, color, img_as_float, exposure
from skimage.morphology import white_tophat, disk, binary_dilation
from skimage.feature import blob_log
from skimage.filters import gaussian

import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle, Circle


# ----------------------------- Detection core ---------------------------------
def detect_blobs_gray(
    gray_image: np.ndarray,
    *,
    tophat_radius: int = 9,
    hot_sigma: float = 15.0,
    hot_thresh: float = 0.25,
    hot_dilate: int = 1,
    min_sigma: float = 0.8,
    max_sigma: float = 6.0,
    num_sigma: int = 15,
    threshold: float = 0.02,
):
    """
    Run the detection pipeline on a GRAYSCALE float image in [0,1].
    Returns (blobs_filtered, g_masked) where blobs is an (N,3) array [y, x, sigma].
    """
    # Local contrast (CLAHE)
    g = exposure.equalize_adapthist(gray_image, clip_limit=0.02)

    # Remove wide glow (white top-hat)
    g = white_tophat(g, footprint=disk(tophat_radius))

    # Mild hot-region mask
    bg = gaussian(g, sigma=hot_sigma, preserve_range=True)
    resid = g - bg
    hot = resid > hot_thresh
    if hot_dilate > 1:
        hot = binary_dilation(hot, footprint=disk(hot_dilate))

    g_masked = g.copy()
    g_masked[hot] = 0.0

    # LoG blob detection (size-capped)
    blobs = blob_log(
        g_masked,
        min_sigma=min_sigma,
        max_sigma=max_sigma,
        num_sigma=num_sigma,
        threshold=threshold,
    )
    if blobs.size > 0:
        blobs = blobs[blobs[:, 2] <= max_sigma]

    return blobs, g_masked


def count_blobs_in_roi(
    src_gray: np.ndarray,
    crop_xyxy: tuple,
    det_params: dict,
):
    """
    Crop src_gray to (x0,y0,x1,y1), detect blobs, return (count, local_blobs, roi_gray_masked).
    local_blobs are in ROI coordinates.
    """
    x0, y0, x1, y1 = crop_xyxy
    H, W = src_gray.shape
    # Clamp
    x0c = max(0, min(W, int(x0)))
    x1c = max(0, min(W, int(x1)))
    y0c = max(0, min(H, int(y0)))
    y1c = max(0, min(H, int(y1)))

    if x1c <= x0c or y1c <= y0c:
        return 0, np.zeros((0, 3), dtype=float), None

    roi = src_gray[y0c:y1c, x0c:x1c]
    blobs, g_masked = detect_blobs_gray(roi, **det_params)
    count = 0 if blobs.size == 0 else len(blobs)
    return count, blobs, g_masked


# ----------------------------- Drawing helpers --------------------------------
def draw_per_cell_preview(
    roi_gray_masked: np.ndarray,
    local_blobs: np.ndarray,
    out_path: Path,
    dpi: int = 150,
):
    """
    Save a small preview for a single cell: masked grayscale ROI + red circles.
    """
    out_path.parent.mkdir(parents=True, exist_ok=True)
    fig, ax = plt.subplots(figsize=(4, 4))
    ax.imshow(roi_gray_masked if roi_gray_masked is not None else np.zeros((10, 10)), cmap="gray")
    if local_blobs is not None and local_blobs.size > 0:
        for (y, x, s) in local_blobs:
            r = float(s) * np.sqrt(2.0)
            ax.add_patch(Circle((float(x), float(y)), r, fill=False, linewidth=0.7))
    ax.set_axis_off()
    fig.savefig(out_path, bbox_inches="tight", dpi=dpi)
    plt.close(fig)


def draw_whole_image_preview(
    image_gray: np.ndarray,
    *,
    grid_rects: list,    # list of (x0,y0,x1,y1)
    pilot_rects: list,   # list of (x0,y0,x1,y1)
    global_blobs: list,  # list of (x, y, r) globally located
    title: str,
    out_path: Path,
    dpi: int = 180,
):
    """
    Draw the whole (optionally flipped) image, faint grid, green pilot cells,
    and all detected blobs as red circles. Save to out_path.
    """
    out_path.parent.mkdir(parents=True, exist_ok=True)
    H, W = image_gray.shape

    fig, ax = plt.subplots(figsize=(min(14, W / 100), min(14, H / 100)))
    ax.imshow(image_gray, cmap="gray")

    # Faint grid in light gray
    for (x0, y0, x1, y1) in grid_rects:
        ax.add_patch(
            Rectangle((x0, y0), max(1, x1 - x0), max(1, y1 - y0),
                      fill=False, linewidth=0.25, edgecolor=(1, 1, 1, 0.35))
        )

    # Pilot cells in green
    for (x0, y0, x1, y1) in pilot_rects:
        ax.add_patch(
            Rectangle((x0, y0), max(1, x1 - x0), max(1, y1 - y0),
                      fill=False, linewidth=1.0, edgecolor=(0, 1, 0, 0.95))
        )

    # Detected dots (global)
    for (x, y, r) in global_blobs:
        ax.add_patch(Circle((x, y), r, fill=False, linewidth=0.7, edgecolor="red"))

    ax.set_xlim(0, W)
    ax.set_ylim(H, 0)   # keep top-down visual (matches your R overlays)
    ax.set_title(title)
    ax.set_axis_off()
    fig.savefig(out_path, bbox_inches="tight", dpi=dpi)
    plt.close(fig)


# ----------------------------- Main pipeline ----------------------------------
def main():
    parser = argparse.ArgumentParser(
        description="Fill y (dot counts) in pilot_to_count.csv; save per-cell and per-image clean previews."
    )
    parser.add_argument("--frame_csv", required=True,
                        help="Path to strata_map_auto.csv (x0,x1,y0,y1,img_path,cell_id).")
    parser.add_argument("--pilot_csv", required=True,
                        help="Path to pilot_to_count.csv (img_path,stratum,cell_id,y).")
    parser.add_argument("--out_csv", required=False,
                        help="Output CSV path. If omitted, overwrites pilot_csv.")
    parser.add_argument("--flip-bitmap", action="store_true",
                        help="Flip the bitmap vertically before counting; maps coords accordingly.")
    parser.add_argument("--preview-dir", type=str, default=None,
                        help="If set, save per-cell clean previews here.")
    parser.add_argument("--preview-every", type=int, default=1,
                        help="Save only 1 of every N per-cell previews (default 1 = all).")
    parser.add_argument("--image-preview-dir", type=str, default=None,
                        help="If set, save one whole-image clean count preview per image.")

    # Detector params
    parser.add_argument("--tophat_radius", type=int, default=9)
    parser.add_argument("--hot_sigma", type=float, default=15.0)
    parser.add_argument("--hot_thresh", type=float, default=0.25)
    parser.add_argument("--hot_dilate", type=int, default=1)
    parser.add_argument("--min_sigma", type=float, default=0.8)
    parser.add_argument("--max_sigma", type=float, default=6.0)
    parser.add_argument("--num_sigma", type=int, default=15)
    parser.add_argument("--threshold", type=float, default=0.02)

    args = parser.parse_args()
    frame_csv = Path(args.frame_csv)
    pilot_csv = Path(args.pilot_csv)
    out_csv = Path(args.out_csv) if args.out_csv else pilot_csv

    det_params = dict(
        tophat_radius=args.tophat_radius,
        hot_sigma=args.hot_sigma,
        hot_thresh=args.hot_thresh,
        hot_dilate=args.hot_dilate,
        min_sigma=args.min_sigma,
        max_sigma=args.max_sigma,
        num_sigma=args.num_sigma,
        threshold=args.threshold,
    )

    # Load tables
    frame = pd.read_csv(frame_csv)
    pilot = pd.read_csv(pilot_csv)

    # Needed columns
    need = ["cell_id", "img_path", "x0", "x1", "y0", "y1"]
    miss = [c for c in need if c not in frame.columns]
    if miss:
        print(f"ERROR: frame CSV missing columns: {miss}", file=sys.stderr)
        sys.exit(2)

    # Join coords onto pilot
    pilot = pilot.merge(frame[need], on=["cell_id", "img_path"], how="left")
    if pilot["x0"].isna().any():
        bad = pilot[pilot["x0"].isna()][["img_path", "cell_id"]].head(10)
        print("ERROR: Some pilot rows have no matching coordinates in frame. Example rows:", file=sys.stderr)
        print(bad.to_string(index=False), file=sys.stderr)
        sys.exit(3)

    # Optionally prepare preview dirs
    preview_dir = Path(args.preview_dir) if args.preview_dir else None
    image_preview_dir = Path(args.image_preview_dir) if args.image_preview_dir else None
    if preview_dir:
        preview_dir.mkdir(parents=True, exist_ok=True)
    if image_preview_dir:
        image_preview_dir.mkdir(parents=True, exist_ok=True)

    # Process per image (avoid reloading many times)
    grouped = pilot.groupby("img_path", sort=False)

    for img_path, df in grouped:
        img_p = Path(img_path)
        if not img_p.exists():
            print(f"WARNING: image not found: {img_path}", file=sys.stderr)
            pilot.loc[df.index, "y"] = 0
            continue

        # Load and grayscale once
        img = io.imread(str(img_p))
        if img.ndim == 2:
            g_full = img_as_float(img)
        else:
            g_full = img_as_float(color.rgb2gray(img))
        H, W = g_full.shape

        # Flip if requested
        if args.flip_bitmap:
            g_used = np.flipud(g_full)
            # Mapping for Y: (y0, y1) -> (H - y1, H - y0)
            def map_y(y0, y1):
                return H - y1, H - y0
        else:
            g_used = g_full
            def map_y(y0, y1):
                return y0, y1

        # For whole-image preview we’ll collect:
        faint_grid = []   # all cells from frame for this image (optional but nice)
        pilot_rects = []  # only pilot cells
        all_global_blobs = []  # (x, y, r) in image coords of g_used

        # Build faint grid rects from frame for this image (if available)
        # (If frame has many rows per image, this is cheap to reuse.)
        frame_this = frame[frame["img_path"] == img_path]
        for _, r in frame_this.iterrows():
            x0, x1 = int(r["x0"]), int(r["x1"])
            y0, y1 = int(r["y0"]), int(r["y1"])
            yy0, yy1 = map_y(y0, y1)
            faint_grid.append((x0, yy0, x1, yy1))

        # Iterate pilot cells
        for k, (idx, row) in enumerate(df.iterrows()):
            x0, x1 = int(row["x0"]), int(row["x1"])
            y0, y1 = int(row["y0"]), int(row["y1"])
            yy0, yy1 = map_y(y0, y1)

            # Count in ROI
            count, local_blobs, roi_masked = count_blobs_in_roi(
                g_used,
                (x0, yy0, x1, yy1),
                det_params,
            )
            pilot.at[idx, "y"] = int(count)

            # Save per-cell preview (throttled)
            if preview_dir and (args.preview_every <= 1 or (k % args.preview_every == 0)):
                base = img_p.stem
                cell_id = str(row["cell_id"]).replace("/", "_")
                out_name = f"{base}_cell_{cell_id}_clean_count.png"
                draw_per_cell_preview(roi_masked, local_blobs, preview_dir / out_name)

            # For whole-image preview, convert local blobs -> global coords
            if local_blobs is not None and local_blobs.size > 0:
                for (ly, lx, s) in local_blobs:
                    r_pix = float(s) * np.sqrt(2.0)
                    gx = float(x0) + float(lx)
                    gy = float(yy0) + float(ly)
                    all_global_blobs.append((gx, gy, r_pix))

            # Collect pilot rect
            pilot_rects.append((x0, yy0, x1, yy1))

        # Save one whole-image clean preview with all dots + pilot cells
        if image_preview_dir is not None:
            title = f"Clean count preview — {img_p.name} (flipped={args.flip_bitmap})"
            out_path = image_preview_dir / f"{img_p.stem}_pilot_clean_count_preview.png"
            draw_whole_image_preview(
                g_used,
                grid_rects=faint_grid,
                pilot_rects=pilot_rects,
                global_blobs=all_global_blobs,
                title=title,
                out_path=out_path,
            )

        print(f"Processed: {img_path} — cells: {len(df)} — total dots: {int(sum(pilot.loc[df.index, 'y']))}")

    # Save CSV
    pilot.to_csv(out_csv, index=False)
    print(f"Wrote counts to: {out_csv}")


if __name__ == "__main__":
    main()
